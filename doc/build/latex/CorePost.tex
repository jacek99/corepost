% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{CorePost Documentation}
\date{March 08, 2012}
\release{0.0.14}
\author{Jacek Furmankiewicz}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\def\PYG@tok@gd{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\def\PYG@tok@gu{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\def\PYG@tok@gt{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.25,0.82}{##1}}}
\def\PYG@tok@gs{\let\PYG@bf=\textbf}
\def\PYG@tok@gr{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\def\PYG@tok@cm{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@vg{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@m{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mh{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@cs{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\colorbox[rgb]{1.00,0.94,0.94}{##1}}}
\def\PYG@tok@ge{\let\PYG@it=\textit}
\def\PYG@tok@vc{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@il{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@go{\def\PYG@tc##1{\textcolor[rgb]{0.19,0.19,0.19}{##1}}}
\def\PYG@tok@cp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@gi{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\def\PYG@tok@gh{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\def\PYG@tok@ni{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\def\PYG@tok@nl{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\def\PYG@tok@nn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@no{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\def\PYG@tok@na{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@nb{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@nd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\def\PYG@tok@ne{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nf{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\def\PYG@tok@si{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\def\PYG@tok@s2{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@vi{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@nt{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\def\PYG@tok@nv{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@s1{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@gp{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@sh{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@ow{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@sx{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@bp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c1{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@kc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@mf{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@err{\def\PYG@bc##1{\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{##1}}}
\def\PYG@tok@kd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@ss{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\def\PYG@tok@sr{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\def\PYG@tok@mo{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mi{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@kn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@o{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\def\PYG@tok@kr{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@s{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@kp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@w{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\def\PYG@tok@kt{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\def\PYG@tok@sc{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sb{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@k{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@se{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sd{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}



\chapter{A Twisted REST micro-framework}
\label{index:a-twisted-rest-micro-framework}\label{index:corepost}

\section{Introduction}
\label{intro:introduction}\label{intro::doc}

\subsection{What is CorePost?}
\label{intro:what-is-corepost}
CorePost is a Python REST micro-framework. It is meant for building enterprise-grade REST server applications that provide
API services to other applications and/or a UI layer (coded in any framework or language).

More importantly, CorePost is an asynchronous I/O web framework (similar to Node.js).
Hence it relies on asynchronous I/O operations, which are extremely efficient, but somewhat more complicated to code.

Fortunately, CorePost does not create it's own async I/O library, but instead uses under the mature, well documented
and extremely well designed Twisted library, in particular its web layer (known simply as twisted.web)

Coupled with a JIT runtime like PyPy, this should give you the ability to develop REST server side applications
that will be extremely performant in production, yet (hopefully) fun and productive to develop.


\subsection{What is Twisted?}
\label{intro:what-is-twisted}
Twisted is a very mature Python async I/O network toolkit:

\href{http://twistedmatrix.com/trac/}{http://twistedmatrix.com/trac/}

Understanding core principles behind Twisted and its APIs is required (at least at a basic level) before coding any CorePost application.

Hence we recommend either reading the very thorough developer's guide:

\href{http://twistedmatrix.com/documents/current/core/howto/book.pdf}{http://twistedmatrix.com/documents/current/core/howto/book.pdf}

or the excellent Twisted tutorials from Dave Peticolas:

\href{http://krondo.com/blog/?page\_id=1327}{http://krondo.com/blog/?page\_id=1327}

In particular, understanding the core Twisted Deferred object (and its productive inline callback approach) are crucial
to productive usage of Twisted APIs for writing asynchronous web applications.


\subsection{What does CorePost add on top of Twisted Web?}
\label{intro:what-does-corepost-add-on-top-of-twisted-web}
Mostly productivity features that take of low-level plumbing such as:
\begin{itemize}
\item {} 
routing request to handler methods

\item {} 
automatic parsing of JSON/YAML/XML input

\item {} 
automatic conversion of Python objects and classes to JSON / YAML / XML formats

\item {} 
simplified exception handling

\item {} 
custom request / response filters

\end{itemize}

However, this is a very thin layer. Once you get to write some serious code that interacts with an external system (e.g. a SQL database)
you are writing a hard-code Twisted web application. CorePost is just there to make it easier for you and let you focus on business logic,
while letting it take care of common required plumbing. That's it.

A CorePost application is nothing more than a \emph{twisted.web} application under the hood.


\subsection{Why would I use CorePost instead of Node.js?}
\label{intro:why-would-i-use-corepost-instead-of-node-js}
As you develop more Twisted code, you will realize how its elegant and powerful \emph{Deferred} object
(and especially inline callbacks) make developing \emph{readable} asynchronous code much more pleasant than any other solution.


\chapter{Features}
\label{index:features}

\section{URL Routing}
\label{url_routing::doc}\label{url_routing:url-routing}

\subsection{@route decorator}
\label{url_routing:route-decorator}
Via a simple \emph{@route} decorator you can automatically route \emph{twisted.web} Request objects to your class method
based on URL (with dynamic paths), HTTP method, expected content type, etc:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{corepost.web} \PYG{k+kn}{import} \PYG{n}{route}\PYG{p}{,} \PYG{n}{RESTResource}
\PYG{k+kn}{from} \PYG{n+nn}{corepost.enums} \PYG{k+kn}{import} \PYG{n}{Http}

\PYG{k}{class} \PYG{n+nc}{RESTService}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}

    \PYG{n+nd}{@route}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{/}\PYG{l+s}{"}\PYG{p}{,}\PYG{n}{Http}\PYG{o}{.}\PYG{n}{GET}\PYG{p}{)}
    \PYG{k}{def} \PYG{n+nf}{root}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{request}\PYG{p}{,}\PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{request}\PYG{o}{.}\PYG{n}{path}

    \PYG{n+nd}{@route}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{/test}\PYG{l+s}{"}\PYG{p}{,}\PYG{n}{Http}\PYG{o}{.}\PYG{n}{GET}\PYG{p}{)}
    \PYG{k}{def} \PYG{n+nf}{test}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{request}\PYG{p}{,}\PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{request}\PYG{o}{.}\PYG{n}{path}

    \PYG{n+nd}{@route}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{/test/\textless{}int:numericid\textgreater{}}\PYG{l+s}{"}\PYG{p}{,}\PYG{n}{Http}\PYG{o}{.}\PYG{n}{GET}\PYG{p}{)}
    \PYG{k}{def} \PYG{n+nf}{test\PYGZus{}get\PYGZus{}resources}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{request}\PYG{p}{,}\PYG{n}{numericid}\PYG{p}{,}\PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{l+s}{"}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{"} \PYG{o}{\PYGZpc{}} \PYG{n}{numericid}

\PYG{k}{if} \PYG{n}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s}{'}\PYG{l+s}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s}{'}\PYG{p}{:}
    \PYG{n}{app} \PYG{o}{=} \PYG{n}{RESTResource}\PYG{p}{(}\PYG{p}{(}\PYG{n}{RESTService}\PYG{p}{,}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{app}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\emph{Note}:
\begin{quote}

This piece of code:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{app}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

is just for convenience when showing code samples and writing unit tests.
In a real production application you would use existing Twisted \emph{twistd} functionality:
\begin{itemize}
\item {} 
\href{http://twistedmatrix.com/documents/current/core/howto/basics.html}{http://twistedmatrix.com/documents/current/core/howto/basics.html}

\item {} 
\href{http://twistedmatrix.com/documents/current/core/howto/application.html}{http://twistedmatrix.com/documents/current/core/howto/application.html}

\item {} 
\href{http://twistedmatrix.com/documents/current/core/howto/tap.html}{http://twistedmatrix.com/documents/current/core/howto/tap.html}

\end{itemize}
\end{quote}


\subsection{Path argument extraction}
\label{url_routing:path-argument-extraction}
CorePort can easily extract path arguments from an URL and convert them to the desired type.

The supported types are:
\begin{itemize}
\item {} 
\emph{int}

\item {} 
\emph{float}

\item {} 
\emph{string}

\end{itemize}

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nd}{@route}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{/int/\textless{}int:intarg\textgreater{}/float/\textless{}float:floatarg\textgreater{}/string/\textless{}stringarg\textgreater{}}\PYG{l+s}{"}\PYG{p}{,}\PYG{n}{Http}\PYG{o}{.}\PYG{n}{GET}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{test}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{request}\PYG{p}{,}\PYG{n}{intarg}\PYG{p}{,}\PYG{n}{floatarg}\PYG{p}{,}\PYG{n}{stringarg}\PYG{p}{,}\PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{pass}
\end{Verbatim}


\subsection{Routing requests by incoming content type}
\label{url_routing:routing-requests-by-incoming-content-type}
Based on the incoming content type in POST/PUT requests, the \emph{same} URL can be hooked up to different router methods:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nd}{@route}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{/post/by/content}\PYG{l+s}{"}\PYG{p}{,}\PYG{p}{(}\PYG{n}{Http}\PYG{o}{.}\PYG{n}{POST}\PYG{p}{,}\PYG{n}{Http}\PYG{o}{.}\PYG{n}{PUT}\PYG{p}{)}\PYG{p}{,}\PYG{n}{MediaType}\PYG{o}{.}\PYG{n}{APPLICATION\PYGZus{}JSON}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{test\PYGZus{}content\PYGZus{}app\PYGZus{}json}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{request}\PYG{p}{,}\PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{request}\PYG{o}{.}\PYG{n}{received\PYGZus{}headers}\PYG{p}{[}\PYG{n}{HttpHeader}\PYG{o}{.}\PYG{n}{CONTENT\PYGZus{}TYPE}\PYG{p}{]}

\PYG{n+nd}{@route}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{/post/by/content}\PYG{l+s}{"}\PYG{p}{,}\PYG{p}{(}\PYG{n}{Http}\PYG{o}{.}\PYG{n}{POST}\PYG{p}{,}\PYG{n}{Http}\PYG{o}{.}\PYG{n}{PUT}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{n}{MediaType}\PYG{o}{.}\PYG{n}{TEXT\PYGZus{}XML}\PYG{p}{,}\PYG{n}{MediaType}\PYG{o}{.}\PYG{n}{APPLICATION\PYGZus{}XML}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{test\PYGZus{}content\PYGZus{}xml}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{request}\PYG{p}{,}\PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{request}\PYG{o}{.}\PYG{n}{received\PYGZus{}headers}\PYG{p}{[}\PYG{n}{HttpHeader}\PYG{o}{.}\PYG{n}{CONTENT\PYGZus{}TYPE}\PYG{p}{]}

\PYG{n+nd}{@route}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{/post/by/content}\PYG{l+s}{"}\PYG{p}{,}\PYG{p}{(}\PYG{n}{Http}\PYG{o}{.}\PYG{n}{POST}\PYG{p}{,}\PYG{n}{Http}\PYG{o}{.}\PYG{n}{PUT}\PYG{p}{)}\PYG{p}{,}\PYG{n}{MediaType}\PYG{o}{.}\PYG{n}{TEXT\PYGZus{}YAML}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{test\PYGZus{}content\PYGZus{}yaml}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{request}\PYG{p}{,}\PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{request}\PYG{o}{.}\PYG{n}{received\PYGZus{}headers}\PYG{p}{[}\PYG{n}{HttpHeader}\PYG{o}{.}\PYG{n}{CONTENT\PYGZus{}TYPE}\PYG{p}{]}

\PYG{n+nd}{@route}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{/post/by/content}\PYG{l+s}{"}\PYG{p}{,}\PYG{p}{(}\PYG{n}{Http}\PYG{o}{.}\PYG{n}{POST}\PYG{p}{,}\PYG{n}{Http}\PYG{o}{.}\PYG{n}{PUT}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{test\PYGZus{}content\PYGZus{}catch\PYGZus{}all}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{request}\PYG{p}{,}\PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{MediaType}\PYG{o}{.}\PYG{n}{WILDCARD}
\end{Verbatim}


\section{Argument validation}
\label{arguments:argument-validation}\label{arguments::doc}
CorePost integrates the popular `formencode' package to implement form and query argument validation.
Validators can be specified using a \emph{formencode} Schema object, or via custom field-specific validators.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{corepost.web} \PYG{k+kn}{import} \PYG{n}{validate}\PYG{p}{,} \PYG{n}{route}
\PYG{k+kn}{from} \PYG{n+nn}{corepost.enums} \PYG{k+kn}{import} \PYG{n}{Http}
\PYG{k+kn}{from} \PYG{n+nn}{formencode} \PYG{k+kn}{import} \PYG{n}{Schema}\PYG{p}{,} \PYG{n}{validators}

\PYG{k}{class} \PYG{n+nc}{TestSchema}\PYG{p}{(}\PYG{n}{Schema}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{allow\PYGZus{}extra\PYGZus{}fields} \PYG{o}{=} \PYG{n+nb+bp}{True}
    \PYG{n}{childId} \PYG{o}{=} \PYG{n}{validators}\PYG{o}{.}\PYG{n}{Regex}\PYG{p}{(}\PYG{n}{regex}\PYG{o}{=}\PYG{l+s}{"}\PYG{l+s}{\PYGZca{}value1\textbar{}value2\PYGZdl{}}\PYG{l+s}{"}\PYG{p}{)}

\PYG{k}{class} \PYG{n+nc}{MyApp}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}

        \PYG{n+nd}{@route}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{/validate/\textless{}int:rootId\textgreater{}/schema}\PYG{l+s}{"}\PYG{p}{,}\PYG{n}{Http}\PYG{o}{.}\PYG{n}{POST}\PYG{p}{)}
        \PYG{n+nd}{@validate}\PYG{p}{(}\PYG{n}{schema}\PYG{o}{=}\PYG{n}{TestSchema}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{k}{def} \PYG{n+nf}{postValidateSchema}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{request}\PYG{p}{,}\PYG{n}{rootId}\PYG{p}{,}\PYG{n}{childId}\PYG{p}{,}\PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
            \PYG{l+s+sd}{'''Validate using a common schema'''}
            \PYG{k}{return} \PYG{l+s}{"}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{ - }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{ - }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{"} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{rootId}\PYG{p}{,}\PYG{n}{childId}\PYG{p}{,}\PYG{n}{kwargs}\PYG{p}{)}

        \PYG{n+nd}{@route}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{/validate/\textless{}int:rootId\textgreater{}/custom}\PYG{l+s}{"}\PYG{p}{,}\PYG{n}{Http}\PYG{o}{.}\PYG{n}{POST}\PYG{p}{)}
        \PYG{n+nd}{@validate}\PYG{p}{(}\PYG{n}{childId}\PYG{o}{=}\PYG{n}{validators}\PYG{o}{.}\PYG{n}{Regex}\PYG{p}{(}\PYG{n}{regex}\PYG{o}{=}\PYG{l+s}{"}\PYG{l+s}{\PYGZca{}value1\textbar{}value2\PYGZdl{}}\PYG{l+s}{"}\PYG{p}{)}\PYG{p}{)}
        \PYG{k}{def} \PYG{n+nf}{postValidateCustom}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{request}\PYG{p}{,}\PYG{n}{rootId}\PYG{p}{,}\PYG{n}{childId}\PYG{p}{,}\PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
            \PYG{l+s+sd}{'''Validate using argument-specific validators'''}
            \PYG{k}{return} \PYG{l+s}{"}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{ - }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{ - }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{"} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{rootId}\PYG{p}{,}\PYG{n}{childId}\PYG{p}{,}\PYG{n}{kwargs}\PYG{p}{)}
\end{Verbatim}

Please see the \emph{FormEncode} documentation:

\href{http://www.formencode.org/en/latest/Validator.html}{http://www.formencode.org/en/latest/Validator.html}

for list of available validators:
\begin{itemize}
\item {} 
Common : \href{http://www.formencode.org/en/latest/modules/validators.html\#module-formencode.validators}{http://www.formencode.org/en/latest/modules/validators.html\#module-formencode.validators}

\item {} 
National : \href{http://www.formencode.org/en/latest/modules/national.html\#module-formencode.national}{http://www.formencode.org/en/latest/modules/national.html\#module-formencode.national}

\end{itemize}


\section{Content types}
\label{content_types::doc}\label{content_types:content-types}
CorePost integrates support for JSON, YAML and XML (partially) based on request content types.


\subsection{Parsing of incoming content}
\label{content_types:parsing-of-incoming-content}
Based on the incoming content type in POST/PUT requests,
the body will be automatically parsed to JSON, YAML and XML (ElementTree)
\begin{itemize}
\item {} 
request.json

\item {} 
request.yaml

\item {} 
request.xml

\end{itemize}

and attached to the request:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nd}{@route}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{/post/json}\PYG{l+s}{"}\PYG{p}{,}\PYG{p}{(}\PYG{n}{Http}\PYG{o}{.}\PYG{n}{POST}\PYG{p}{,}\PYG{n}{Http}\PYG{o}{.}\PYG{n}{PUT}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{test\PYGZus{}json}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{request}\PYG{p}{,}\PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{l+s}{"}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{"} \PYG{o}{\PYGZpc{}} \PYG{n}{json}\PYG{o}{.}\PYG{n}{dumps}\PYG{p}{(}\PYG{n}{request}\PYG{o}{.}\PYG{n}{json}\PYG{p}{)}

\PYG{n+nd}{@route}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{/post/xml}\PYG{l+s}{"}\PYG{p}{,}\PYG{p}{(}\PYG{n}{Http}\PYG{o}{.}\PYG{n}{POST}\PYG{p}{,}\PYG{n}{Http}\PYG{o}{.}\PYG{n}{PUT}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{test\PYGZus{}xml}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{request}\PYG{p}{,}\PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{l+s}{"}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{"} \PYG{o}{\PYGZpc{}} \PYG{n}{ElementTree}\PYG{o}{.}\PYG{n}{tostring}\PYG{p}{(}\PYG{n}{request}\PYG{o}{.}\PYG{n}{xml}\PYG{p}{)}

\PYG{n+nd}{@route}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{/post/yaml}\PYG{l+s}{"}\PYG{p}{,}\PYG{p}{(}\PYG{n}{Http}\PYG{o}{.}\PYG{n}{POST}\PYG{p}{,}\PYG{n}{Http}\PYG{o}{.}\PYG{n}{PUT}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{test\PYGZus{}yaml}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{request}\PYG{p}{,}\PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{l+s}{"}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{"} \PYG{o}{\PYGZpc{}} \PYG{n}{yaml}\PYG{o}{.}\PYG{n}{dump}\PYG{p}{(}\PYG{n}{request}\PYG{o}{.}\PYG{n}{yaml}\PYG{p}{)}
\end{Verbatim}


\subsection{Converting Python objects to expected content type}
\label{content_types:converting-python-objects-to-expected-content-type}
Instead of returning string responses, the code can just return Python objects.
Depending whether the caller can accept JSON (default) or YAML, the Python objects will be automatically converted:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nd}{@route}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{/return/by/accept}\PYG{l+s}{"}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{test\PYGZus{}return\PYGZus{}content\PYGZus{}by\PYGZus{}accepts}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{request}\PYG{p}{,}\PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{val} \PYG{o}{=} \PYG{p}{[}\PYG{p}{\PYGZob{}}\PYG{l+s}{"}\PYG{l+s}{test1}\PYG{l+s}{"}\PYG{p}{:}\PYG{l+s}{"}\PYG{l+s}{Test1}\PYG{l+s}{"}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+s}{"}\PYG{l+s}{test2}\PYG{l+s}{"}\PYG{p}{:}\PYG{l+s}{"}\PYG{l+s}{Test2}\PYG{l+s}{"}\PYG{p}{\PYGZcb{}}\PYG{p}{]}
    \PYG{k}{return} \PYG{n}{val}
\end{Verbatim}

Calling this URL with ``Accept: application/json'' will return:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{p}{\PYGZob{}}\PYG{l+s}{"}\PYG{l+s}{test1}\PYG{l+s}{"}\PYG{p}{:} \PYG{l+s}{"}\PYG{l+s}{Test1}\PYG{l+s}{"}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+s}{"}\PYG{l+s}{test2}\PYG{l+s}{"}\PYG{p}{:} \PYG{l+s}{"}\PYG{l+s}{Test2}\PYG{l+s}{"}\PYG{p}{\PYGZcb{}}\PYG{p}{]}
\end{Verbatim}

Calling it with ``Accept: text/yaml'' will return:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{o}{-} \PYG{p}{\PYGZob{}}\PYG{n}{test1}\PYG{p}{:} \PYG{n}{Test1}\PYG{p}{\PYGZcb{}}
\PYG{o}{-} \PYG{p}{\PYGZob{}}\PYG{n}{test2}\PYG{p}{:} \PYG{n}{Test2}\PYG{p}{\PYGZcb{}}
\end{Verbatim}


\section{Filters}
\label{filters::doc}\label{filters:filters}
There is support for CorePost resource filters via the two following \emph{corepost.filter} interfaces:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{IRequestFilter}\PYG{p}{(}\PYG{n}{Interface}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{"""Request filter interface"""}
    \PYG{k}{def} \PYG{n+nf}{filterRequest}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{request}\PYG{p}{)}\PYG{p}{:}
        \PYG{l+s+sd}{"""Allows to intercept and change an incoming request"""}
        \PYG{k}{pass}

\PYG{k}{class} \PYG{n+nc}{IResponseFilter}\PYG{p}{(}\PYG{n}{Interface}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{"""Response filter interface"""}
    \PYG{k}{def} \PYG{n+nf}{filterResponse}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{request}\PYG{p}{,}\PYG{n}{response}\PYG{p}{)}\PYG{p}{:}
        \PYG{l+s+sd}{"""Allows to intercept and change an outgoing response"""}
        \PYG{k}{pass}
\end{Verbatim}

A filter class can implement either of them or both (for a wrap around filter), e.g.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{AddCustomHeaderFilter}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{"""Implements a request filter that adds a custom header to the incoming request"""}
    \PYG{n}{zope}\PYG{o}{.}\PYG{n}{interface}\PYG{o}{.}\PYG{n}{implements}\PYG{p}{(}\PYG{n}{IRequestFilter}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{filterRequest}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{request}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{request}\PYG{o}{.}\PYG{n}{received\PYGZus{}headers}\PYG{p}{[}\PYG{l+s}{"}\PYG{l+s}{Custom-Header}\PYG{l+s}{"}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{"}\PYG{l+s}{Custom Header Value}\PYG{l+s}{"}

\PYG{k}{class} \PYG{n+nc}{Change404to503Filter}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{"""Implements just a response filter that changes 404 to 503 statuses"""}
    \PYG{n}{zope}\PYG{o}{.}\PYG{n}{interface}\PYG{o}{.}\PYG{n}{implements}\PYG{p}{(}\PYG{n}{IResponseFilter}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{filterResponse}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{request}\PYG{p}{,}\PYG{n}{response}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{response}\PYG{o}{.}\PYG{n}{code} \PYG{o}{==} \PYG{l+m+mi}{404}\PYG{p}{:}
            \PYG{n}{response}\PYG{o}{.}\PYG{n}{code} \PYG{o}{=} \PYG{l+m+mi}{503}

\PYG{k}{class} \PYG{n+nc}{WrapAroundFilter}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{"""Implements both types of filters in one class"""}
    \PYG{n}{zope}\PYG{o}{.}\PYG{n}{interface}\PYG{o}{.}\PYG{n}{implements}\PYG{p}{(}\PYG{n}{IRequestFilter}\PYG{p}{,}\PYG{n}{IResponseFilter}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{filterRequest}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{request}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{request}\PYG{o}{.}\PYG{n}{received\PYGZus{}headers}\PYG{p}{[}\PYG{l+s}{"}\PYG{l+s}{X-Wrap-Input}\PYG{l+s}{"}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{"}\PYG{l+s}{Input}\PYG{l+s}{"}

    \PYG{k}{def} \PYG{n+nf}{filterResponse}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{request}\PYG{p}{,}\PYG{n}{response}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{response}\PYG{o}{.}\PYG{n}{headers}\PYG{p}{[}\PYG{l+s}{"}\PYG{l+s}{X-Wrap-Output}\PYG{l+s}{"}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{"}\PYG{l+s}{Output}\PYG{l+s}{"}
\end{Verbatim}

In order to activate the filters on a RESTResource instance, you need to pass a list of them in the constructor as the \emph{filters} parameter, e.g.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{FilterApp}\PYG{p}{:}

    \PYG{n+nd}{@route}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{/}\PYG{l+s}{"}\PYG{p}{,}\PYG{n}{Http}\PYG{o}{.}\PYG{n}{GET}\PYG{p}{)}
    \PYG{k}{def} \PYG{n+nf}{root}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{request}\PYG{p}{,}\PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{request}\PYG{o}{.}\PYG{n}{received\PYGZus{}headers}

\PYG{k}{def} \PYG{n+nf}{run\PYGZus{}filter\PYGZus{}app}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{app} \PYG{o}{=} \PYG{n}{RESTResource}\PYG{p}{(}\PYG{n}{services}\PYG{o}{=}\PYG{p}{(}\PYG{n}{FilterApp}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{p}{)}\PYG{p}{,}\PYG{n}{filters}\PYG{o}{=}\PYG{p}{(}\PYG{n}{Change404to503Filter}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{AddCustomHeaderFilter}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{WrapAroundFilter}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{app}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{l+m+mi}{8083}\PYG{p}{)}
\end{Verbatim}


\section{HTTP codes}
\label{http_codes::doc}\label{http_codes:http-codes}
By default, CorePost returns the appropriate HTTP code based on the HTTP method:

Success:
\begin{itemize}
\item {} 
200 (OK) - GET, DELETE, PUT

\item {} 
201 (Created) - POST

\end{itemize}

Errors:
\begin{itemize}
\item {} 
404 - not able to match any URL.

\item {} 
400 - missing mandatory argument (driven from the arguments on the actual functions)

\item {} 
400 - argument failed validation

\item {} 
500 - server error

\end{itemize}


\section{Asynchronous Operations}
\label{async:asynchronous-operations}\label{async::doc}

\subsection{@defer.inlineCallbacks support}
\label{async:defer-inlinecallbacks-support}
If you want a deferred async method, just use \emph{defer.returnValue()}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nd}{@route}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{/}\PYG{l+s}{"}\PYG{p}{,}\PYG{n}{Http}\PYG{o}{.}\PYG{n}{GET}\PYG{p}{)}
\PYG{n+nd}{@defer.inlineCallbacks}
\PYG{k}{def} \PYG{n+nf}{root}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{request}\PYG{p}{,}\PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{val1} \PYG{o}{=} \PYG{k}{yield} \PYG{n}{db}\PYG{o}{.}\PYG{n}{query}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{SELECT ....}\PYG{l+s}{"}\PYG{p}{)}
        \PYG{n}{val2} \PYG{o}{=} \PYG{k}{yield} \PYG{n}{db}\PYG{o}{.}\PYG{n}{query}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{SELECT ....}\PYG{l+s}{"}\PYG{p}{)}
        \PYG{n}{defer}\PYG{o}{.}\PYG{n}{returnValue}\PYG{p}{(}\PYG{n}{val1} \PYG{o}{+} \PYG{n}{val2}\PYG{p}{)}
\end{Verbatim}

This is standard Twisted functionality.


\section{Modular REST applications}
\label{modules::doc}\label{modules:modular-rest-applications}
A typical case in REST is where you have parent/child resources (business entities), e.g.

\begin{Verbatim}[commandchars=\\\{\}]
Customer

        Customer Address

        Customer Phone

        Customer Order

                Customer Invoice

                        Customer Invoice Payment
\end{Verbatim}

etc.

This can create a URL structure like:

\begin{Verbatim}[commandchars=\\\{\}]
/customer

/customer/\textless{}customerId\textgreater{}

/customer/\textless{}customerId\textgreater{}/address

/customer/\textless{}customerId\textgreater{}/address/\textless{}addressId\textgreater{}

/customer/\textless{}customerId\textgreater{}/phone

/customer/\textless{}customerId\textgreater{}/phone/\textless{}phoneId\textgreater{}

/customer/\textless{}customerId\textgreater{}/invoice

/customer/\textless{}customerId\textgreater{}/invoice/\textless{}invoiceId\textgreater{}

/customer/\textless{}customerId\textgreater{}/invoice/\textless{}invoiceId\textgreater{}/payment

/customer/\textless{}customerId\textgreater{}/invoice/\textless{}invoiceId\textgreater{}/payment/\textless{}paymentId\textgreater{}
\end{Verbatim}

CorePost allows you to write small, modular classes that implement a REST service for just a single entity,
driven by URL paths with dynamic elements in them (e.g. the \emph{customerId}, \emph{invoiceId}, \emph{paymentId} path parameters in the sample above).
You do not have to mesh all these different entities in a single class.

At the end, you wrap all of the different REST services in a single \emph{RESTResource} object (which extends the regular Twisted Web Resource object)
and it takes care of routing the request to the appropriate class.

Here is a full-blown example of two REST services for Customer and Customer Address:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{corepost} \PYG{k+kn}{import} \PYG{n}{Response}\PYG{p}{,} \PYG{n}{NotFoundException}\PYG{p}{,} \PYG{n}{AlreadyExistsException}
\PYG{k+kn}{from} \PYG{n+nn}{corepost.web} \PYG{k+kn}{import} \PYG{n}{RESTResource}\PYG{p}{,} \PYG{n}{route}\PYG{p}{,} \PYG{n}{Http}

\PYG{k}{class} \PYG{n+nc}{CustomerRESTService}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{path} \PYG{o}{=} \PYG{l+s}{"}\PYG{l+s}{/customer}\PYG{l+s}{"}

    \PYG{n+nd}{@route}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{/}\PYG{l+s}{"}\PYG{p}{)}
    \PYG{k}{def} \PYG{n+nf}{getAll}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{request}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{DB}\PYG{o}{.}\PYG{n}{getAllCustomers}\PYG{p}{(}\PYG{p}{)}

    \PYG{n+nd}{@route}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{/\textless{}customerId\textgreater{}}\PYG{l+s}{"}\PYG{p}{)}
    \PYG{k}{def} \PYG{n+nf}{get}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{request}\PYG{p}{,}\PYG{n}{customerId}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{DB}\PYG{o}{.}\PYG{n}{getCustomer}\PYG{p}{(}\PYG{n}{customerId}\PYG{p}{)}

    \PYG{n+nd}{@route}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{/}\PYG{l+s}{"}\PYG{p}{,}\PYG{n}{Http}\PYG{o}{.}\PYG{n}{POST}\PYG{p}{)}
    \PYG{k}{def} \PYG{n+nf}{post}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{request}\PYG{p}{,}\PYG{n}{customerId}\PYG{p}{,}\PYG{n}{firstName}\PYG{p}{,}\PYG{n}{lastName}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{customer} \PYG{o}{=} \PYG{n}{Customer}\PYG{p}{(}\PYG{n}{customerId}\PYG{p}{,} \PYG{n}{firstName}\PYG{p}{,} \PYG{n}{lastName}\PYG{p}{)}
        \PYG{n}{DB}\PYG{o}{.}\PYG{n}{saveCustomer}\PYG{p}{(}\PYG{n}{customer}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{Response}\PYG{p}{(}\PYG{l+m+mi}{201}\PYG{p}{)}

    \PYG{n+nd}{@route}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{/\textless{}customerId\textgreater{}}\PYG{l+s}{"}\PYG{p}{,}\PYG{n}{Http}\PYG{o}{.}\PYG{n}{PUT}\PYG{p}{)}
    \PYG{k}{def} \PYG{n+nf}{put}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{request}\PYG{p}{,}\PYG{n}{customerId}\PYG{p}{,}\PYG{n}{firstName}\PYG{p}{,}\PYG{n}{lastName}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{c} \PYG{o}{=} \PYG{n}{DB}\PYG{o}{.}\PYG{n}{getCustomer}\PYG{p}{(}\PYG{n}{customerId}\PYG{p}{)}
        \PYG{p}{(}\PYG{n}{c}\PYG{o}{.}\PYG{n}{firstName}\PYG{p}{,}\PYG{n}{c}\PYG{o}{.}\PYG{n}{lastName}\PYG{p}{)} \PYG{o}{=} \PYG{p}{(}\PYG{n}{firstName}\PYG{p}{,}\PYG{n}{lastName}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{Response}\PYG{p}{(}\PYG{l+m+mi}{200}\PYG{p}{)}

    \PYG{n+nd}{@route}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{/\textless{}customerId\textgreater{}}\PYG{l+s}{"}\PYG{p}{,}\PYG{n}{Http}\PYG{o}{.}\PYG{n}{DELETE}\PYG{p}{)}
    \PYG{k}{def} \PYG{n+nf}{delete}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{request}\PYG{p}{,}\PYG{n}{customerId}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{DB}\PYG{o}{.}\PYG{n}{deleteCustomer}\PYG{p}{(}\PYG{n}{customerId}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{Response}\PYG{p}{(}\PYG{l+m+mi}{200}\PYG{p}{)}

    \PYG{n+nd}{@route}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{/}\PYG{l+s}{"}\PYG{p}{,}\PYG{n}{Http}\PYG{o}{.}\PYG{n}{DELETE}\PYG{p}{)}
    \PYG{k}{def} \PYG{n+nf}{deleteAll}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{request}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{DB}\PYG{o}{.}\PYG{n}{deleteAllCustomers}\PYG{p}{(}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{Response}\PYG{p}{(}\PYG{l+m+mi}{200}\PYG{p}{)}

\PYG{k}{class} \PYG{n+nc}{CustomerAddressRESTService}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{path} \PYG{o}{=} \PYG{l+s}{"}\PYG{l+s}{/customer/\textless{}customerId\textgreater{}/address}\PYG{l+s}{"}

    \PYG{n+nd}{@route}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{/}\PYG{l+s}{"}\PYG{p}{)}
    \PYG{k}{def} \PYG{n+nf}{getAll}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{request}\PYG{p}{,}\PYG{n}{customerId}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{DB}\PYG{o}{.}\PYG{n}{getCustomer}\PYG{p}{(}\PYG{n}{customerId}\PYG{p}{)}\PYG{o}{.}\PYG{n}{addresses}

    \PYG{n+nd}{@route}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{/\textless{}addressId\textgreater{}}\PYG{l+s}{"}\PYG{p}{)}
    \PYG{k}{def} \PYG{n+nf}{get}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{request}\PYG{p}{,}\PYG{n}{customerId}\PYG{p}{,}\PYG{n}{addressId}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{DB}\PYG{o}{.}\PYG{n}{getCustomerAddress}\PYG{p}{(}\PYG{n}{customerId}\PYG{p}{,} \PYG{n}{addressId}\PYG{p}{)}

    \PYG{n+nd}{@route}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{/}\PYG{l+s}{"}\PYG{p}{,}\PYG{n}{Http}\PYG{o}{.}\PYG{n}{POST}\PYG{p}{)}
    \PYG{k}{def} \PYG{n+nf}{post}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{request}\PYG{p}{,}\PYG{n}{customerId}\PYG{p}{,}\PYG{n}{addressId}\PYG{p}{,}\PYG{n}{streetNumber}\PYG{p}{,}\PYG{n}{streetName}\PYG{p}{,}\PYG{n}{stateCode}\PYG{p}{,}\PYG{n}{countryCode}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{c} \PYG{o}{=} \PYG{n}{DB}\PYG{o}{.}\PYG{n}{getCustomer}\PYG{p}{(}\PYG{n}{customerId}\PYG{p}{)}
        \PYG{n}{address} \PYG{o}{=} \PYG{n}{CustomerAddress}\PYG{p}{(}\PYG{n}{streetNumber}\PYG{p}{,}\PYG{n}{streetName}\PYG{p}{,}\PYG{n}{stateCode}\PYG{p}{,}\PYG{n}{countryCode}\PYG{p}{)}
        \PYG{n}{c}\PYG{o}{.}\PYG{n}{addresses}\PYG{p}{[}\PYG{n}{addressId}\PYG{p}{]} \PYG{o}{=} \PYG{n}{address}
        \PYG{k}{return} \PYG{n}{Response}\PYG{p}{(}\PYG{l+m+mi}{201}\PYG{p}{)}

    \PYG{n+nd}{@route}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{/\textless{}addressId\textgreater{}}\PYG{l+s}{"}\PYG{p}{,}\PYG{n}{Http}\PYG{o}{.}\PYG{n}{PUT}\PYG{p}{)}
    \PYG{k}{def} \PYG{n+nf}{put}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{request}\PYG{p}{,}\PYG{n}{customerId}\PYG{p}{,}\PYG{n}{addressId}\PYG{p}{,}\PYG{n}{streetNumber}\PYG{p}{,}\PYG{n}{streetName}\PYG{p}{,}\PYG{n}{stateCode}\PYG{p}{,}\PYG{n}{countryCode}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{address} \PYG{o}{=} \PYG{n}{DB}\PYG{o}{.}\PYG{n}{getCustomerAddress}\PYG{p}{(}\PYG{n}{customerId}\PYG{p}{,} \PYG{n}{addressId}\PYG{p}{)}
        \PYG{p}{(}\PYG{n}{address}\PYG{o}{.}\PYG{n}{streetNumber}\PYG{p}{,}\PYG{n}{address}\PYG{o}{.}\PYG{n}{streetName}\PYG{p}{,}\PYG{n}{address}\PYG{o}{.}\PYG{n}{stateCode}\PYG{p}{,}\PYG{n}{address}\PYG{o}{.}\PYG{n}{countryCode}\PYG{p}{)} \PYG{o}{=} \PYG{p}{(}\PYG{n}{streetNumber}\PYG{p}{,}\PYG{n}{streetName}\PYG{p}{,}\PYG{n}{stateCode}\PYG{p}{,}\PYG{n}{countryCode}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{Response}\PYG{p}{(}\PYG{l+m+mi}{200}\PYG{p}{)}

    \PYG{n+nd}{@route}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{/\textless{}addressId\textgreater{}}\PYG{l+s}{"}\PYG{p}{,}\PYG{n}{Http}\PYG{o}{.}\PYG{n}{DELETE}\PYG{p}{)}
    \PYG{k}{def} \PYG{n+nf}{delete}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{request}\PYG{p}{,}\PYG{n}{customerId}\PYG{p}{,}\PYG{n}{addressId}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{DB}\PYG{o}{.}\PYG{n}{getCustomerAddress}\PYG{p}{(}\PYG{n}{customerId}\PYG{p}{,} \PYG{n}{addressId}\PYG{p}{)} \PYG{c}{\PYGZsh{}validate address exists}
        \PYG{k}{del}\PYG{p}{(}\PYG{n}{DB}\PYG{o}{.}\PYG{n}{getCustomer}\PYG{p}{(}\PYG{n}{customerId}\PYG{p}{)}\PYG{o}{.}\PYG{n}{addresses}\PYG{p}{[}\PYG{n}{addressId}\PYG{p}{]}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{Response}\PYG{p}{(}\PYG{l+m+mi}{200}\PYG{p}{)}

    \PYG{n+nd}{@route}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{/}\PYG{l+s}{"}\PYG{p}{,}\PYG{n}{Http}\PYG{o}{.}\PYG{n}{DELETE}\PYG{p}{)}
    \PYG{k}{def} \PYG{n+nf}{deleteAll}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{request}\PYG{p}{,}\PYG{n}{customerId}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{c} \PYG{o}{=} \PYG{n}{DB}\PYG{o}{.}\PYG{n}{getCustomer}\PYG{p}{(}\PYG{n}{customerId}\PYG{p}{)}
        \PYG{n}{c}\PYG{o}{.}\PYG{n}{addresses} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n}{Response}\PYG{p}{(}\PYG{l+m+mi}{200}\PYG{p}{)}


\PYG{k}{def} \PYG{n+nf}{run\PYGZus{}rest\PYGZus{}app}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{app} \PYG{o}{=} \PYG{n}{RESTResource}\PYG{p}{(}\PYG{p}{(}\PYG{n}{CustomerRESTService}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{CustomerAddressRESTService}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{app}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{l+m+mi}{8080}\PYG{p}{)}

\PYG{k}{if} \PYG{n}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s}{"}\PYG{l+s}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s}{"}\PYG{p}{:}
    \PYG{n}{run\PYGZus{}rest\PYGZus{}app}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}



\renewcommand{\indexname}{Index}
\printindex
\end{document}
